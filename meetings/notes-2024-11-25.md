# 2024-11-21 ECMA-402 Meeting

## Logisticsh

### Attendees

- Shane Carr - Google i18n (SFC), Co-Moderator
- Yusuke Suzuki - Apple (YSZ)
- Louis-Aimé de Fouquières - Invited Expert (LAF) (only for a while)
- Eemeli Aro - Mozilla (EAO)
- Ben Allen - Igalia (BAN)
- Jesse Alama - Igalia (JMN)
- Frank Yung-Fong Tang - Google i18n, V8 (FYT)
- Richard Gibson - OpenJS Foundation (RGN)
- Henri Sivonen - Mozilla (HJS)
- J. S. Choi - Invited Expert (JSC)
- Zibi Braniecki - Mozilla (ZB)

### Standing items

- [Discussion Board](https://github.com/tc39/ecma402/projects/2)
- [Status Wiki](https://github.com/tc39/ecma402/wiki/Proposal-and-PR-Progress-Tracking) -- please update!
- [Abbreviations](https://github.com/tc39/notes/blob/master/delegates.txt)
- [MDN Tracking](https://github.com/tc39/ecma402-mdn)
- [Meeting Calendar](https://calendar.google.com/calendar/embed?src=unicode.org_nubvqveeeol570uuu7kri513vc%40group.calendar.google.com)
- [Matrix](https://matrix.to/#/#tc39-ecma402:matrix.org)

## Status Updates

### Updates from the Editors

BAN: (discusses merged PRs and work on Measure proposal. Many new test262 tests for recent PRs)

### Updates from the MessageFormat Working Group

EAO: We think we might be done, in that there's an issue currently open auditing whether to accept the current state of the MF2 spec as ready from the perspective of the working group, to recommend to the CLDR-TC as a non-preview specification. It means that the stability policy would be enforced starting hopefully from its release in CLDR 47. Meanwhile, CLDR 46.1 will have the text.

EAO: Next steps: new explainer, new user guide. Current text is “inside baseball” stuff. Documentation site built by LCA and a few others at messageformat.dev, not an official documentation site yet, but likely to become the official documentation side. Within the next few weeks, once the ballot concludes and an explainer doc is available, I’d like to ask TG2 as a whole to take a look at this thing – is it a fit-for-purpose message formatting specification? Related news: JavaScript library MessageFormat I’ve been maintaining, to an extent a polyfill, has been updated to match the final version of MessageFormat 2.0 spec – you can even play around with the real thing with this. That’s it for me! Only question: for review, file issue in ECMA-402 repo, or some other action?

SFC: Email to delegates list might be appropriate course of action. Technical discussion should be in issues, asking people to do something is what email is for.

EAO: Will also open ECMA-402 issue to have somewhere to talk about this.

SFC: Already have an issue for Intl.Messageformat, also have the MessageFormat repo

EAO: MessageFormat2.0 is not quite the same thing as the Intl.MessageFormat API.

SFC: One other update, the TG5 user study, Micheal Coblenz is working on that. Also had a meeting in October, chatted with MF and KG who had been delegates from TG1 most hesitant to put weight behind MessageFormat. Sense I get from MF and KG is that a lot of things we were planning to do (have early adopters integrate it into their systems?) is it very much aligned with what KG and MF are talking about, given the amount of confidence we want to have for Intl.MessageFormat in plenary. Polyfill is good, show that it works for developers/clients of Web platform. What we’re doing is the right thing to do to help move Intl.MessageFormat along, my expectation is that if 2025 goes according to plan, we’ll be in a good position to ask for Intl.MessageFormat stage 2. One thing MF said, once Intl.MessageFormat does get to stage 2, there will be a low bar to get to stage 3. Stage 2 the main stage, proven the direction we definitely want to do, once that’s done there’s not much to do in Stage 3 or Stage 4. Work frontloaded. Once we have a spec, can point to stakeholders, we have evidence it works on the Web platform (TG5) study, that’s what we need to finish the job. That’s how I see Intl.MessageFormat moving forward in 2025. 

EAO: Some of the relatively late-breaking changes we’ve applied to spec: We ended up adding the small number of new functions that are part of the standard, that implement behavior that’s available already in JavaScript. However, while Intl.NumberFormat does a lot of different numeric formatting, in MF2 we’ll have `:number` as a generic function, `:integer` which guarantees that number formatting is an integer, and we have `:currency`, that is specifically doing currency, and a proposed `:unit` for unit formatting, which does include a `usage` option that would allow for locale- and value-specific conversions. This is a capability we don’t have in Intl.NumberFormat. We also have `:math`, with which you can do integer addition/subtraction. This provides a better alternative to “plural with offset” in ICU MessageFormat 1, a specific sort of selection that is occasionally useful and necessary. Wanted to highlight this as we ended up going in a different direction than Intl.NumberFormat has done. For the vast majority of MessageFormat 2, we’re using the same option names and values as Intl.NumberFormat and Intl.DateTimeFormat, but because of the split into different functions (e.g. `:currency`), some of the option names have been altered.

JSC: Is there a chance that the findings of the user study would result in changes to the MessageFormat 2 spec? Or will the MF2 spec be frozen before the study ends?

SFC: I had this question as well, and the answer is that the alignment I was able to get here is twofold. The stability policy of the 402 spec lets you (for example) create new characters to do certain things, we can add them, that’s fine, that works. ICU MessageFormat 1 might not be able to read MessageFormat 2. MessageFormat can deprecate syntax that had existed in MessageFormat. You can add stuff, and you can deprecate stuff. It would have been nice to have the user survey sooner. Shape of formatters, options of formatting stable, something I do think will be informed by the study. To answer the question, the user study cannot reshape, but can make changes at the edges.

EAO: To clarify further, earlier on the MF2 spec, for the stability, we guaranteed forward compatibility. We changed this to allow for more feedback that comes after 2.0, whether that feedback comes from TG5 or another source.

### Updates from Implementers

https://github.com/tc39/ecma402/wiki/Proposal-and-PR-Progress-Tracking

YSZ: JSC side, right now we are not having much update, basically we’re working on bug fixing for the past several months, not focusing on feature, we have an update in the next month, right now we don’t have that.

FYT: Not much change from v8 side, already shipped LocaleInfo and new functions. Used to be some getter in v8, tried to get rid of that, Safari removed those things, Chromium has concerns that we won’t break for someone who depends on it, but that shouldn’t be the case and I’m in the process of changing it. Other thing, unrelated to proposal, we used to have an old proprietor of v8 [?]. We are now considering removing the v8 break iterator(?). Hopefully we can remove those proprietary things.

FYT: For the 2025 edition, where’s the last TC39 do we have to have to go to stage 4?

SFC: It would be nice to have things in November meeting because of three month gap, but generally we say that things that land in February can go in ES25. If you wait for February meeting, it should be completely ready – all feedback on PRs is resolved, so on and so forth. We want to hit the ground running in March to generate the draft, so that we can send it for the opt-out period and all that. In practice, end of February we want the spec done, it is plausible to get stage 4 at February, but it must be ready to go in February. Does that align with your expectations, BAN and RGN?

BAN: thumbs up

RGN: That makes sense to me.

### Updates from the W3C i18n Group

BAN: Syncing with Addison early next week. 

## Proposals and Discussion Topics

https://github.com/tc39/ecma402/projects/2

### Year precision #10

https://github.com/tc39/proposal-intl-eradisplay/issues/10

SFC: I’ve been working on semantic skeletons a lot, may get it into ECMA-402, but in the short term there is the eraDisplay proposal. One thing we found in the CLDR-WG regarding this is that whether to show the era is one dimension, but there’s another option we want to consider: do we show the century? This is very much in the same space; in Gregorian you can display 2 digit year, 4 digit year, 4 digit year with eras. What I’ve implemented in ICU4X are the first three options:

- "auto" (allows '24, 2024, 2024 AD)
- "full" (allows 2024, 2024 AD)
- "withEra" (allows 2024 AD)

In ICU4X, should be in ICU4C some time, then 402. I want to make sure this is implementable, we can make a proposal in 402 but if it’s not implemented you can’t do it. Once we have ICU4C we could wrap it in 402. 

LAF: Here you are only considering the current year: 2024. You have to also consider the year before current era. Even if you set it, the mechanisms(?) are all the same, the way it is displayed may be different. I’ve written a comment – I’ve tried to display different years with not exactly your proposal. Also I would say is “what CLDR says”. CLDR in U.S. English, you would say things like in LAF comment. 

SFC: The intent of “full” is to show the full era when necessary.

LAF: It’s like full year in JavaScript, you put a year as integer number. By the way, in ISO the year has to be in (?). The ISO calendar as it is now is from, but [?]. Except if we want to cover the special case in U.S. representing the year with their version. In my opinion to stick with, I want there to be return with era, even if it’s today’s era. And in the other case, we want to not display era ever. So it would be this very particular figure here, where in the place of the year you have 2, and this is in a test where the era is implied by context. In documents in history, of course, they don’t cite before C.E., they say “it was in year 2,” 700, something. And we all know that it’s before CE, because we’re talking about Rome or something like that. I think, after thought, impliedEra might be omitted. 

SFC: Yes, that’s probably the least useful of these options. One thing we should probably discuss, this is a question for everyone on the call, is what to call these options. The option that I call full, the expect that the display would be: 2024: 2024, 1924: 1924, -1: -1

SFC: Speaking about “numeric” that would be the thing that I called “full”, but what I called “full” is not represented on this. 

LAF: Only one calendar counts backwards: the Julian calendar, not the proleptic Gregorian. Only in this calendar do you count years in the reverse way, starting with “1” and then “1 before.” 

FYT: Taiwan-ROC is like that too. 

LAF: Ah, yes!

FYT: There are others. Julian is not the only one.

LAF: I’m pretty sure, now that ROC and Julian are the only ones.

FYT: Let me check

LAF: That’s interesting. In Taiwan do they really use it?

FYT: Yes, they do. 

LAF: It would be interesting to check for the Japanese calendar, for reign-based[?] date. And that’s all. For Thai calendar it starts very very backwards, so I’m not sure they would do that.

LAF: Decision: “numeric” is a good idea.

SFC: “numeric” could describe the thing you had described as “full”

LAF: Yes, exactly.

SFC: And we don’t have a name for what I named “full”

FYT: I think Coptic has it too?

LAF: The Coptic calendar is the [?] calendar, they just changed it by adding leap years. 

LAF: In (?) they solve it by putting the era 500 before, what they call the incarnation, and Coptic, I’m pretty sure, just starts a new reckoning system, with the leap year. They didn’t want to do that before, but so say some historian had used the Coptic calendar counting backwards? Not sure. The way of counting backwards was (?) in the 8th century, something like that. But okay. 

EAO: Well, why are we talking about this? We have one calendar that counts backwards, so we don’t have to think of it further.

LAF: The thing is that the [?] is using four countries at least with a second calendar. But the thing is that there is not much use of these tools by historians, as of now. But it could come. 

SFC: Yes, the number of calendars, that we can investigate later. What I’m asking this group is if we want to agree as a group for having the 2 digit or 4 digit year be part of it. Maybe something called “yearStyle”? Is that an option worth pursuing?

LAF: +1

RGN: I just wanted to observe if you’re committed to that option, it rhymes with NumberFormat.signDisplay. Might be useful for naming the ones for the era indicator. 

EAO: I was just going to say that effectively in the calendar we tend to use, a century is an era.

LAF: Yes

EAO: So having it in era display would be appropriate, if perhaps a little surprising. In an appropriately weird way I think. I am happier to make people who want to use 2 digit years feel uncomfortable about not specifying the era they’re using.

#### Conclusion

- Good to move forward with centuries also handled with this option
- Investigate new option name and values

### Intl DurationFormat for Stage 4

https://github.com/tc39/proposal-intl-duration-format/issues/209

BAN: There's a big editorial PR that I was making based on feedback from MF. I'm going to double check if that is really needed for Stage 4.

SFC: There were some questions in September about test coverage. Have those concerns been addressed?

BAN: It looks like Anba closed the issue, so I think so?

YSZ: I support Intl.DurationFormat for Stage 4. In terms of test coverage, I believe it is good, and I'd like to hear the V8 side opinion. But from JSC side we are ready with the current spec, we think it is safe to count JSC as an implementation. 

FYT: We are ready for that

YSZ: Perfect

#### Conclusion

Add to the TG1 agenda.

### Normative: Add 8 new numbering systems for Unicode 16 #929

https://github.com/tc39/ecma402/pull/929

FYT: if Unicode has updated it – ICU has it, etc., it shouldn’t be an implementation problem with other implementor concern about adding that to the spec.

SFC: Thank you for making this. We’ve had this PR every year for every Unicode release, and we’ve said that we’ll make a best-effort attempt to keep this list updated. If 76 is out and available, we can merge the PR.

YSZ: Do we have information when 76 gets released?

SFC: I believe it got released around October 25th, something like that?

YSZ: I see.

SFC: I think once you’re happy with merging this, we can bring this forward to TG1. Do we bring it before this meeting, or wait for February? I think we should do it before this meeting.

YSZ: I’d like to have discussion time internally with the ICU folks. JSC is pretty much using the system ICU, we just released with ICU 74, which means ICU 76 will come relatively quickly(?). I’d like to know about the timelines of these things, or also we can wait a bit for implementation?

SFC: There’s two weeks before TG1 call, but Thanksgiving is in the middle there. Do you want to have a discussion now, or go to February.

YSZ: It’s something nice if we could have the next February TG1. This time I know the status, that sort of thing, right now it is hard to see – folks are already on vacation. 

SFC: That’s fine, there’s not a particular rush for this one. If you can have feedback for January TG2, we can put it up for February TG1

EAO: A side comment; we got a question about en-ZA styling changing

SFC: Is that in CLDR 76?

EAO: It happened in the summer

SFC: That’s 75.

EAO: So I was tracking the issue and the change landed in CLDR in the summer. I wanted to see what we were doing differently from everyone else, it’s because we were already using 76 in Firefox.

SFC: Do you know when v8 will ship 76?

FYT: They are working on it. I don’t have a huge concern, they are going to do it. Making this into the spec will help me push them to do it.

SFC: Cool

### Why is there no Intl.Locale.prototype.variants? #900

https://github.com/tc39/ecma402/issues/900

ZB: What’s a use case?

FYT: variants is kind of legacy.

SFC: variants are part of the core four types of subtags, I do think variants are relevant and should have a getter. If the only reason they aren't included is because we weren't sure if they were useful, I think they absolutely are useful.

EAO: I think the only locale that we care about here is catalan as spoken in Valencia.

ZB: We use regional override (?) when you have a language spoken in a different reason, instead of adding variants. SFC, I know that’s useful for CLDR data, but ECMA-402 is not primarily concerned with giving CLDR directly. I’m concerned about introducing a solution with no problem. 

SFC: I’ll write on the issue why I think why it’s motivated. Also, the region should use a subdivision subtag, not even a full subtag.

ZB: You’re right. 

SFC: and it’s Catalan and not Spanish, it should be something more like ca-ES-u-sd-esvc. But I will point out that we don’t have a getter for subdivision, so I don’t know if that helps much.

ZB: We don’t have getters for the whole unicode extension? Wait, we do.

SFC: We have a few for a few we’ve picked

ZB: So maybe subdivision is something we should add a getter for.

SFC: Variants not just used for subdivisions, also used for for example IPA phonetics, fonipa is something that gets used for variants, and there’s other uses for variants. I think that’s an example of something that should be a transform, not a variant. Some of these use cases for variant should be done with other things, but this is how it’s been represented for many many years. I think it’s really – I’m very surprised we’re having this discussion, because variants exist, they work, people maybe shouldn’t be using them anymore, but they are used, and have been used, and they solve some problems, and they should be part of the spec.

FYT: Doesn’t need to be a getter, getter for variant is a little complicated. The form of the variant, is that we’re returning, is it an array or a single tag or a single string or an array of string, will it be sorted or not? The Japanese one from one to two, it’s complicated.

ZB: Slovakian example is very complicated. We should – I don’t think it’s sufficient justification that JS engines should roll out a getter for it.

FYT: You can get the information from the locale – it’s a little clunky to read it, but for something that no one usually reads.

SFC: Conclusion I have here is that there are some complications, we should consider discussing on the issue, since we don’t have it now we could add it once we’re in agreement about both the shape and the motivation. I think it’s motivated, but there’s questions about the shape, we need to figure out something there before we can move on with the proposal.

FYT: Think of it this way: variant is [practically?] deprecated, do we really want to add support for legacy stuff instead of replacing it? 

#### Conclusion

- Questions about motivation and shape
- Continue discussing on the issue

### Display Names Data Slicing

https://github.com/unicode-org/icu4x/issues/3260

SFC: DisplayNames data is very big, one of the biggest pieces of data in ICU, and when we shipped [?] it was because browsers were already shipping this data. But there were questions about how we should do the selection of regions and thinks. Do we need to support all languages, and all scripts in all languages? And how do we support slicing of this in ICU4X. ZB raised the idea that it would be good to have feedback from implementers, since that will inform where we go. 

ZB: To make it more practical for the audience, the thesis we’re putting with SFC here, when you use DisplayNames to acquire names of regions, there’s two axes on which we have to think of it. Which locales do I support, can I translate it into [several languages]. And what regions do we provide translations for? And the data size is a matrix of those two axes. So we have a good mechanism to determine which locales you ship. So when you look at JS engines and environments, they will most likely go for defaults, and we have to be prepared for it, and if a locale is not in default there’s not much of a chance that it will be in [various platforms]. But now for which regions are we going to have data? If we say let’s have data for all possible regions and all possible languages, we explode the payload for DisplayNames. And that puts strain on [?] where I continually get questions about do we have to download 60 mb of locale data, can we get it down to 20? If some of that is obscure region names, I would prefer to add another locale that my engine will support, rather than by maintaining 300 to 400 region names. We want to give people some flexibility in slicing this data and what to include in the JS engine, but on the other hand don’t ask customers all the region names they want. They’re not equipped to manually select that. One idea that SFC had is that we could have “core” and “extended”, but how do we make that decision/

FYT: Region names are limited, right? There are 240 of them? Language names are a much bigger space. It could go to several thousand.

HJS: So, ZB, how would you subset the regions to be named? Currently the browsers support the regions that CLDR knows about. I don’t see any good principled way of deciding that these particular regions are not important enough, especially now that browsers have already been doing this, and there are JS libraries out there that assume that they’re able to do a global region picker where the strings come from the browser. Whether that’s a good idea or not to make that JS library, but if it’s not a good idea it’s not a good idea to have DisplayNames in the first place – water under the bridge, DisplayNames already added. [missed a bit]

SFC: A few things here. One is maybe – I’m saying “core” and “extended”, but maybe three buckets: “minimal”, “core”, “extended”. “Extended” could have a thousand or more languages, but they don’t have any entry in CLDR. Hopefully more of these languages will eventually get data, but they’re not supported in intl APIs, browsers don’t ship them, and that’s a place to draw the line. If a browser doesn’t ship support for a given language, why do we have DisplayNames for it? If browsers aren’t shipping it, it shouldn’t be in DisplayName.

In “minimal”, every language would have the regions in which it was used. For example Italy is a region we support, Chinese is a language we support, do we need the display name of Italy in Chinese? We have it now, it’s supported, it’s fine, but in Chinese we need the DisplayName of Mongolia, of maybe Thailand? But do we need the display name for Finnish in Chinese? It’s “core”, but maybe it’s not “minimal”. We also have the problem that the “core” set is made to depend on each browser, different implementations may have different ideas about what to have in “core” or “extended”. 

ZB: What I hear from HJS is, how do we make a decision, and how are we going to provide backward compatibility? I think the arbitration here is problematic. The counterpoint that I’m bringing is that “if not us, then who?” If we don’t make this decision, or take on us the burden of controlling some in Unicode of what is “core”, what is “minimal”, then we’re kicking the can down the road by saying “we don’t want to make this decision, so we’re going to support all the keys.” And what we’re avoiding saying is that someone somewhere is going to make a tough decision about whether to include DisplayNames or not, because we didnt give them much flexibility. And the contexts where JS are use run increasingly toward less disk space. If all we have is 100 mb, how much of that can be taken up by localization? At which point does the project manager say “let’s not include DisplayNames at all” or “let’s not consider adding Intl at all”? The question is who and how we’re going to provide capabilities for that. I would advice us to take up this challenge. In terms of backward compatibility, we make clear that 402 just provides the clearest output. If you give a language/region that doesn’t exist, you just get the input. We’re thinking of esoteric edge cases, and those tradeoffs will continue happening. Maybe Firefox will cut out the bottom 100, 200 names in DisplayNames. 

The final comment I’d like to make is that DisplayNames is a, and has always been, an open-ended API. Right now we support four types in DisplayNames, but ever since we introduced this we’ve thought we’d introduce more. Add lots of fields on top of region-script-currency. Thinking hard about which regions we include, which scripts, which time zones, is required to avoid a binary “everything or nothing” scenario.

HJS: So DisplayNames for regions is already unreliable in the sense that you get a different name output in different browsers. And whether that’s a problem or not, I don’t know, for different sites, but clearly there are sites and JS libraries that trust the browser output, so that level of unreliability is not a practical blocker. Perhaps the writers of these libraries don’t know about this stuff, or do but accept it. Currently you can trust that you get output – except in one case, let’s ignore that – and if you start subseting it in a way that’s unreliable, at what point does the API become so unreliable that you might as well not ship DisplayNames at all. If you the person writing the JavaScript don’t trust if this thing works, what does it matter that we have DisplayNames for the small footprint when it’s so unreliable.

HJS: Edge omits currencies that are historical. But it seems important for interoperability that browsers do whatever and programmers get whatever results, an open-ended API in that sense does not seem like a good thing.

EAO: Two different thoughts. You mentioned, ZB, about it becoming a binary choice – include DisplayNames or not. This might be a good way to handle this. DisplayNames is most useful when you can trust that it works the way you want it to work. But if in some browsers it works the way you want it to work unreliably, that makes it less useful. I think a split of whether this thing is working or is not working might be really quite useful, since if it’s not working you can easily detect that and go to a fallback. Separately, though, this is related to some of the other data loading issues. Commonly in these sort of question we’re interested in solving the general problem: having all the languages, etc. But the user is indicating what their preferred language is, and if we’re slicing the data we could ensure that it’s relatively complete for languages in Accept-Languages, and for that to be made available to them. 

ZB: Let me push back on this. Let’s think about a use case. The main use case of DisplayNames was presenting language dropdown pickers. We even had a conversation back then with someone from Mozilla, I think Anne van Kesteren (?). Said it should be an HTML element that displays flags and languages, because developers are not in a position to pick what languages are in these pickers, or they have a set of assets and “we have these four or five”. We talk about the privacy and fingerprinting vector – if I provide an arbitrary number of languages I can inspect them and increase my fingerprinting surface. I can add it to my fingerprinting. I mainly want to push back on the idea that a binary choice is a right choice. I can’t think of a use case where a developer only benefits from DisplayNames because they have 2000s of them, because I can’t think of a scenario where they want to display 2000 languages. The select probably contains about 50. Adding 350 languages in locales to DisplayNames, I don’t think it improves the Web or customer experience in and scenario. It’s gated by language. I guess I’m maybe underthinking what the use cases of DisplayNames are, other than fingerprinting. In a picker, though, the top 50 languages are the ones that are used, the bottom 1000 are not used by anyone and blow the payload of every browser in the world. 

FYT: In Google Translate we have more than 100 languages there. One of the things that we want to push is that they currently bundle that with the translations every time they ship it, but the original intention was that they could migrate to this. But the languages they support is definitely not the top 50 – at least 130, 150 now. But we don’t have it currently in our translation, so I don’t know if it would be helpful anyway, but to show you: sometimes it’s more than 50.

ZB: Here’s an example of a proposal for DisplayNames v2, to add unit names. And if we don’t have this conversation now, is it a binary choice? Do you support some units, not others? [?] a countable number of units, out of a pool of thousands. I’m glad CLDR is collecting 2000, but it’s probably in “extended”. 

HJS: I wasn’t here when DisplayNames was added, but before dateTimeFields were added to DisplayNames, you can look at the API and infer the purpose that this stuff belongs in the API so that any kind of language tag or locale id that the browser could somehow expose, the browser also knows how to render to human-readable text. That seems to be the point from looking at the API, it may not be how it is use. But when dateTimeFields, why is that in it? Why should this particular thing, of dateTimeField labels, not use whatever localization system that the Web site use in general, why should that get the data from the browser and trust that they’re getting it from the browser. Additionally, if the site knows about – it knows what language it’s displaying its UI text in, text it’s not getting from the browser in general. If I display this page in language a, I have this picker with these items, I’m responsible for providing the names for other languages. It seems unintuitive that some strings should come from the browser.

HJS: As for “can we take it back”, that’s more complicated. How much does this cost? Not uncompressed, the DisplayNames are 927 kb. The region display names deduplicated but not compressed is 140(?) kb, scripts, (?), and then dateTImeFields plus measurement units plus currencies including historical is 1mb uncompressed, and names of currencies including uncompressed are 842kb. Looking at how it’s used, I tried to reason about what you could trust about these, and I thought no one would dare to use this stuff because of how unreliable it is. But if NumberFormat is the most used Intl API is 100% scale, then DisplayNames is 1.3%. DisplayNames is way down the list, but it’s there. But then within DisplayNames, it turns out region display names are the most popular. There are these JS libraries where they have to provide their own list of what the space of regions are, but assume the browser uses the name. If you assume that the region use case is 100%, [some missed], dateTimeZone is more than I expected, script is less than 0.5%, and calendar is 0.08% when region is 100%. For better or worse, when this has been out there for this long there is now this legacy out there where there are JS libraries that assume they can do a region picker where they bring the list of all the regions in CLDR they can depend on the browser to render the display name however they wish. So I’m skeptical of being able to subset the regions. I’m quite optimistic that we could get rid of historical currency names.

ZB: This is great analysis, thank you.

HJS: Earlier I asked, why is it the case that display names displays this browser-provided UI strings? Why do we believe that it is appropriate to display names for datetime fields? When I asked on github I didn’t get a good answer. Why do we believe that it’s appropriate for 402 to include display names for dateTimeFields rather than having the browsers know how to provide them? Why does it belong in this API?

FYT: It’s part of CLDR data. 

HJS: If I’m an app developer it’s a source I can draw from with, but if you’re making a Web app why would you have this special case for these particular labels in your UI, why do you need an API to get those display names at a huge cost to the browser, instead of using whatever mechanism you use for UI strings in general for those field names

SFC: Part of the motivation here, and it’s a little bit of a patchwork, but part of the motivation here is if you do a formatToParts, which is common to do with DateTimeFormat, it’s useful. [...] Can be used as a label for UI elements, which is niche – “okay, you gave us the label, but you didn’t give you the list of month names?” We had a lot of other things that was going to be in DisplayNames, and we whittled it down. I would be surprised if this is more than a kilobyte for all locales. I could see us adding number field as another type of thing, so that everything coming out of formatToParts has a label. I agree that it’s not super well motivated, but it’s motivated. And the cost for this is quite low – you can probably look back in notes to find a better answer.

HJS: ZB notes that the size is a problem, it’s a bad thing that these things get in without being super well motivated. 

SFC: ZB said this?

HJS: No, it’s a lot of data in DisplayNames in general, and anything that gets added to that pile – more is more. I agree that it looks like in retrospect dateTimeFields, when we added it it was free because they were already there, but we weren’t looking that far ahead. I

FYT: About dateTimeField: Date Time Field was removed in Intl.DisplayNames v1 but added back in v2 per https://github.com/tc39/proposal-intl-displaynames-v2/issues/18. It was discussed and agree in TC39 April 2021 Meeting
https://github.com/tc39/notes/blob/main/meetings/2021-04/apr-20.md#intl-display-names-v2-for-stage-3.

HJS: For the units stuff, it would be great to have an idea of how much data it would add.

### Add support for more currency symbol variants (e.g. formal) #643

EAO: When formatting currencies, we have the options symbol, narrowSymbol, code, name. Context for why I’m raising this now is that when implementing :currency, we ended up including two further options not on the list but present in the data that we are including for currency formatting. One is the formal symbol, that’s where, for example, if you’re formatting in en-CA, Canadian English, and you’re formatting a US Dollar, if you format as symbol you’ll get US$, if you format with narrow, it’s just $. But if you format with en-US, symbol is going to be $ as well. In en-US, there’s no way to format a currency using US$ as the indicated. So that would be “formal”, as in the title there. One part that I would add here is whether the name we ended up picking for all of this in MFv2, we ended up with “formalSymbol” to match the “symbol” and “narrowSymbol” options. Then the other option value that’s added in MFv2 is “never”, which formats a currency using currency formatting styles, for example the number of fractional digits that is currency dependent. Currently it’s not possible to format a currency without having a code or symbol or name next to it. So the idea is to add “never.” A few locales and currency combinations has a variant field that we didn’t add to MFv2 because it was confusing to figure out how users would use it. The only currency for which this is defined is the TL (Turkish Lira), most of the other variant values are similarly variants like this, I don’t think we should add variant support because it’s challenging and difficult to use. Should we add these, and separately what’s the right form of adding these? Should it go through the staging process, or is it a change that can go in a PR?

SFC: I think that it was – have you spoken much with Mark Davis and others about this question? One reason we’ve been dragging a little bit on adding this feature is that it’s not clear what the right way to specify this – do you say “I want formal currency”? Is it an option of the currency formatter or is it an option for the currency specifically – you could have a message written in a casual form but with the currency formal. I think that’s one of the open questions on the issue.

EAO: From the point of view of Intl.NumberFormat the only way of having this come in is [?]. So it’s just kind of no obviously the other way. It feels weird to me that we have these two options, “give me the narrowest symbol”, or “symbol”, which is sometimes narrowSymbol and sometimes not, and there’s no way to always get the longer variant. 

SFC: I think – the reason that we have a toggle between “symbol” and “narrowSymbol” is that the currency may or may not be implied by context. It’s the developer telling us if the currency is implied by context. Forcing the formal symbol or not is not really something that is – I guess it would be valid to have a flag to be like “try not to use narrowSymbol”, because I want to be extremely explicit about what currencies are being displayed, but I don’t think that’s “formalSymbol” – call it a “wideSymbol” or something like that. As far as I know the “formal” symbol – you give a few examples here – was introduced because there’s some currencies in East Asia where the symbol changes in some contexts, like financial contexts vs casual ones. If it’s a thing about the context of the string, that could impact NumberFormat, but it’s not a NumberFormat option, it’s a context option. Even if we add it to Intl.NumberFormat, it doesn’t necessarily mean it should be in the bag of options that MessageFormat passes to us.

EAO: An example context where it might make sense, you need to format values in multiple different currencies… maybe a mix of US dollars and CA collars. If you opt to be formatting these sorts of currencies in “en-US”, we don’t provide a way to format a value that makes it clear that this is a US dollar, instead of just getting the $. Could be Canadian dollars, Zimbabwean dollars, etc. Not being able to specify your own currency in terms of it being specifically this one seems a bit like a wart. 

SFC: I don’t know if I have much to have, but I wanted to clarify that when I used the word “formal” I meant it specifically to mean the CLDR formal opt variant, which isn’t exactly the use case you’re describing. I agree with the use case you’re describing, but there’s two different name. When you said “formal” I thought you were talking about the formal symbols in East Asian currencies. But wanting the wide symbol is a good use case. If CLDR doesn’t have the data, we should ask them to add it.

EAO: The other part I was trying to figure out is, is this a big enough thing where it needs to go through staging process, or not?

SFC: I think this is a big enough issue that it should probably be a proposal, but it doesn’t have to be a big proposal. It’s okay to have small proposals. I think we’ve discussed previously where the line is between PR and proposal, and the line we had is that PRs should be small and extremely straightforward. There’s things we need to discuss and get alignment on, so it should be a proposal. With a PR the only concern is that it’s scheduled correctly, so that they can ship it. But because there’s design questions, it should be a proposal. We could bring it up at TG1 three times and be done.

EAO: Then I would like to ask for support for introducing this at the upcoming meeting as a Stage 1 proposal so that we can have the space to discuss what to call options, or changing things altogether. Also [something] the meta symbol.

SFC: +1. The line for Stage 1 is “this a good thing to address?”, so I would support a proposal.

BAN: +1

#### Conclusion

EAO to create a Stage 1 proposal and add it to the December TG1 agenda.

### Measure Proposal

https://github.com/tc39-transfer/proposal-measure/blob/main/meetings/slides-2024-11-21.pdf

EAO: I think the mathematical operations are feature creep.
 
BAN: That would simplify things

SFC: I have a separate discussion about potentially merging Decimal behavior into Measure. The mathematical operations should be conditional on that broader approach. My slides:

https://docs.google.com/presentation/d/1Uzrf-IwPrljF2BhCbCWuwQxlgGSm_bcd3FRbPO3Yrio/edit#slide=id.p
